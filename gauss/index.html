<!--
  Gauss's Law Visualizer (2D)
  ============================
  Usage: Open this file in any modern browser (double-click index.html).
  Controls:
  - Add +1 or -1 charges, drag to move, click to select.
  - Choose Gaussian surface shape and resize with sliders.
  - Field Density: higher = more arrows. Flux Resolution: controls surface arrows count.
  - Fullscreen button for projector use.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gauss's Law</title>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=106371504', 'ym');

    ym(106371504, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", referrer: document.referrer, url: location.href, accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/106371504" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --panel-w: 310px;
  --bg: #f0f4f8;
  --panel-bg: #ffffff;
  --canvas-bg: #ffffff;
  --card-bg: #f1f5f9;
  --border: #d1d9e6;
  --text: #1e293b;
  --text-dim: #64748b;
  --accent: #2563eb;
  --positive: #dc2626;
  --negative: #2563eb;
  --surface-color: #b45309;
  --green: #15803d;
  --radius: 8px;
}

html, body {
  height: 100%;
  overflow: hidden;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
}

#app { display: flex; height: 100vh; width: 100vw; }

/* ── Left Panel ── */
#panel {
  width: var(--panel-w);
  min-width: var(--panel-w);
  background: var(--panel-bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
  box-shadow: 2px 0 8px rgba(0,0,0,0.04);
}
#panel::-webkit-scrollbar { width: 6px; }
#panel::-webkit-scrollbar-track { background: transparent; }
#panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.panel-header {
  padding: 16px 18px 12px;
  border-bottom: 1px solid var(--border);
  font-size: 16px;
  font-weight: 800;
  letter-spacing: 0.3px;
  color: var(--accent);
}

.section {
  padding: 14px 18px;
  border-bottom: 1px solid var(--border);
}

.section-title {
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
  margin-bottom: 10px;
}

/* Buttons */
.btn-row { display: flex; gap: 8px; flex-wrap: wrap; }

.btn {
  flex: 1;
  min-width: 0;
  padding: 10px 6px;
  border: 1.5px solid var(--border);
  border-radius: var(--radius);
  background: var(--card-bg);
  color: var(--text);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s, border-color 0.15s, box-shadow 0.15s;
  text-align: center;
  white-space: nowrap;
}
.btn:hover { border-color: var(--accent); box-shadow: 0 1px 4px rgba(37,99,235,0.12); }

.btn.positive { color: var(--positive); border-color: rgba(220,38,38,0.3); }
.btn.positive:hover { background: rgba(220,38,38,0.06); border-color: var(--positive); }
.btn.negative { color: var(--negative); border-color: rgba(37,99,235,0.3); }
.btn.negative:hover { background: rgba(37,99,235,0.06); border-color: var(--negative); }

.btn.delete-selected {
  background: #475569;
  color: #ffffff;
  border-color: #475569;
}
.btn.delete-selected:hover { background: #334155; border-color: #334155; }

/* Sliders */
.slider-group { margin-bottom: 10px; }
.slider-group:last-child { margin-bottom: 0; }
.slider-label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 4px;
}
.slider-label .val { color: var(--text); font-weight: 600; font-variant-numeric: tabular-nums; }

input[type=range] {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: #cbd5e1;
  outline: none;
  cursor: pointer;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: var(--accent);
  border: 2px solid #fff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  cursor: grab;
}
input[type=range]::-moz-range-thumb {
  width: 18px; height: 18px;
  border-radius: 50%;
  background: var(--accent);
  border: 2px solid #fff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  cursor: grab;
}

/* Shape selector */
.shape-selector { display: flex; gap: 6px; }
.shape-btn {
  flex: 1;
  padding: 8px 4px;
  border: 2px solid var(--border);
  border-radius: var(--radius);
  background: var(--card-bg);
  color: var(--text-dim);
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  text-align: center;
  transition: all 0.15s;
}
.shape-btn.active {
  border-color: var(--surface-color);
  color: var(--surface-color);
  background: rgba(180,83,9,0.06);
}
.shape-btn:hover:not(.active) { border-color: #94a3b8; }

/* Readouts */
.readout-card {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 12px;
  margin-bottom: 8px;
}
.readout-card:last-child { margin-bottom: 0; }
.readout-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 3px 0;
  font-size: 13px;
}
.readout-row .label { color: var(--text-dim); }
.readout-row .value {
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  font-family: 'Courier New', monospace;
  font-size: 13px;
}
.readout-row .value.pos-val { color: var(--positive); }
.readout-row .value.neg-val { color: var(--negative); }
.readout-row .value.net-val { color: var(--surface-color); font-size: 15px; }
.readout-row .value.green-val { color: var(--green); }


.divider { border: none; border-top: 1px solid var(--border); margin: 6px 0; }

/* Canvas area */
#canvas-wrap {
  flex: 1;
  position: relative;
  overflow: hidden;
  background: var(--canvas-bg);
}
canvas { display: block; width: 100%; height: 100%; }

.tools-link {
  position: absolute;
  top: 12px;
  right: 14px;
  padding: 8px 16px;
  background: #2563eb;
  color: #fff;
  font-size: 13px;
  font-weight: 600;
  border-radius: 8px;
  text-decoration: none;
  box-shadow: 0 2px 6px rgba(37,99,235,0.3);
  transition: background 0.15s;
  z-index: 10;
}
.tools-link:hover { background: #1d4ed8; }

/* Toggle button for mobile panel */
#panelToggle {
  display: none;
}

/* ── Mobile ── */
@media (max-width: 768px) {
  #app {
    flex-direction: column;
  }

  #canvas-wrap {
    flex: 1;
    min-height: 0;
    order: 1;
  }

  #panel {
    order: 2;
    width: 100%;
    min-width: 100%;
    max-height: 45vh;
    border-right: none;
    border-top: 1px solid var(--border);
    box-shadow: 0 -2px 8px rgba(0,0,0,0.06);
    transition: max-height 0.3s ease;
    overflow-y: auto;
  }

  #panel.collapsed {
    max-height: 0;
    overflow: hidden;
    border-top: none;
  }

  #panelToggle {
    display: block;
    order: 2;
    width: 100%;
    padding: 10px;
    background: var(--panel-bg);
    border: none;
    border-top: 1px solid var(--border);
    color: var(--accent);
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    text-align: center;
    letter-spacing: 0.5px;
  }
  #panelToggle:active { background: var(--card-bg); }

  #panel .panel-header { display: none; }

  .section { padding: 10px 14px; }
  .section-title { margin-bottom: 8px; }

  .btn { padding: 10px 4px; font-size: 12px; }

  input[type=range]::-webkit-slider-thumb { width: 24px; height: 24px; }
  input[type=range]::-moz-range-thumb { width: 24px; height: 24px; }

  .tools-link { padding: 6px 12px; font-size: 12px; top: 8px; right: 8px; }

  .readout-row { font-size: 12px; }
  .readout-row .value { font-size: 12px; }
  .readout-row .value.net-val { font-size: 13px; }
}

@media (max-width: 420px) {
  .btn { font-size: 11px; padding: 9px 2px; }
  .shape-btn { font-size: 11px; padding: 7px 2px; }
  .tools-link { padding: 5px 10px; font-size: 11px; }
}
</style>
</head>
<body>
<div id="app">
  <div id="panel">
    <div class="panel-header">Gauss's Law</div>

    <!-- Charges -->
    <div class="section">
      <div class="section-title">Charges</div>
      <div class="btn-row" style="margin-bottom:10px">
        <button class="btn positive" id="btnAddPos">+ Charge (+1)</button>
        <button class="btn negative" id="btnAddNeg">&minus; Charge (&minus;1)</button>
      </div>
      <div class="btn-row">
        <button class="btn delete-selected" id="btnDelete">Delete Selected</button>
        <button class="btn" id="btnReset">Reset</button>
      </div>
    </div>

    <!-- Gaussian Surface -->
    <div class="section">
      <div class="section-title">Gaussian Surface</div>
      <div class="shape-selector" style="margin-bottom:12px">
        <button class="shape-btn active" data-shape="circle">Circle</button>
        <button class="shape-btn" data-shape="square">Square</button>
        <button class="shape-btn" data-shape="rect">Rect</button>
      </div>
      <div id="surfaceSliders"></div>
    </div>

    <!-- Visualization -->
    <div class="section">
      <div class="section-title">Visualization</div>
      <div class="slider-group">
        <div class="slider-label"><span>Field Density</span><span class="val" id="densityVal">5</span></div>
        <input type="range" id="densitySlider" min="0" max="10" step="1" value="5">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Flux Resolution</span><span class="val" id="fluxResVal">30</span></div>
        <input type="range" id="fluxResSlider" min="0" max="80" step="1" value="30">
      </div>
    </div>

    <!-- Flux Readouts -->
    <div class="section" style="flex:1 0 auto;">
      <div class="section-title">Flux Readouts</div>
      <div id="fluxReadouts"></div>
    </div>

  </div>

  <button id="panelToggle">&#9650; Controls</button>

  <div id="canvas-wrap">
    <canvas id="c"></canvas>
    <a class="tools-link" href="https://classroom-tools.pages.dev/" target="_blank">All Classroom Tools</a>
  </div>
</div>

<script>
"use strict";

// ══════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════
const state = {
  charges: [],
  nextId: 1,
  selected: null,
  surface: {
    shape: "circle",
    cx: 0, cy: 0,
    radius: 150,
    side: 250,
    width: 300,
    height: 200,
  },
  density: 5,       // 1-10, higher = more arrows
  fluxRes: 30,      // number of flux arrows on surface
  dragging: null,
};

// ══════════════════════════════════════════════
// DOM
// ══════════════════════════════════════════════
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const wrap = document.getElementById("canvas-wrap");
const app = document.getElementById("app");

// ══════════════════════════════════════════════
// HELPERS
// ══════════════════════════════════════════════
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function fmt(v) {
  if (Math.abs(v) < 0.0005) return "0";
  return v.toFixed(3);
}

// ══════════════════════════════════════════════
// CANVAS SIZING
// ══════════════════════════════════════════════
let W = 0, H = 0, dpr = 1;
function resize() {
  dpr = window.devicePixelRatio || 1;
  const rect = wrap.getBoundingClientRect();
  W = rect.width;
  H = rect.height;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + "px";
  canvas.style.height = H + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resize);
resize();
state.surface.cx = W / 2;
state.surface.cy = H / 2;

// ══════════════════════════════════════════════
// CHARGE MANAGEMENT (fixed ±1)
// ══════════════════════════════════════════════
function addCharge(sign) {
  const id = state.nextId++;
  state.charges.push({
    id,
    q: sign > 0 ? 1 : -1,
    x: W / 2 + (Math.random() - 0.5) * 60,
    y: H / 2 + (Math.random() - 0.5) * 60,
  });
  selectCharge(id);
}

function removeCharge(id) {
  state.charges = state.charges.filter(c => c.id !== id);
  if (state.selected === id) selectCharge(null);
}

function selectCharge(id) {
  state.selected = id;
}

// ══════════════════════════════════════════════
// PHYSICS — 2D Coulomb Law
// E = q * r_vec / (2π * (r² + ε²))
// Gauss's law 2D: ∮ E·n̂ dl = q_enclosed (ε₀ = 1)
// ══════════════════════════════════════════════
const EPS = 0.1;
const EPS2 = EPS * EPS;
const TWO_PI = 2 * Math.PI;

function electricField(px, py) {
  let Ex = 0, Ey = 0;
  for (let i = 0; i < state.charges.length; i++) {
    const c = state.charges[i];
    const dx = px - c.x;
    const dy = py - c.y;
    const r2 = dx * dx + dy * dy + EPS2;
    const inv = c.q / (TWO_PI * r2);
    Ex += inv * dx;
    Ey += inv * dy;
  }
  return [Ex, Ey];
}

// ══════════════════════════════════════════════
// SURFACE GEOMETRY
// ══════════════════════════════════════════════
function surfaceBounds() {
  const s = state.surface;
  if (s.shape === "circle") {
    return { x: s.cx - s.radius, y: s.cy - s.radius, w: 2 * s.radius, h: 2 * s.radius };
  }
  const hw = s.shape === "square" ? s.side / 2 : s.width / 2;
  const hh = s.shape === "square" ? s.side / 2 : s.height / 2;
  return { x: s.cx - hw, y: s.cy - hh, w: hw * 2, h: hh * 2 };
}

function pointInsideSurface(px, py) {
  const s = state.surface;
  if (s.shape === "circle") {
    const dx = px - s.cx, dy = py - s.cy;
    return dx * dx + dy * dy <= s.radius * s.radius;
  }
  const hw = s.shape === "square" ? s.side / 2 : s.width / 2;
  const hh = s.shape === "square" ? s.side / 2 : s.height / 2;
  return Math.abs(px - s.cx) <= hw && Math.abs(py - s.cy) <= hh;
}

// ══════════════════════════════════════════════
// FLUX COMPUTATION
// Uses high internal resolution for accuracy,
// returns per-side values + sample points for arrows.
// ══════════════════════════════════════════════
function computeFlux() {
  const s = state.surface;
  const N = state.fluxRes;           // visual arrows count
  const COMPUTE_N = Math.max(N, 500); // internal resolution for accuracy
  const result = {
    net: 0, top: 0, bottom: 0, left: 0, right: 0,
    perSide: false,
    arrows: [],  // { px, py, nx, ny, ex, ey, eDotN } for drawing
  };

  if (state.charges.length === 0) return result;

  if (s.shape === "circle") {
    result.perSide = false;
    // High-res computation
    const circumference = TWO_PI * s.radius;
    const dlC = circumference / COMPUTE_N;
    let flux = 0;
    for (let i = 0; i < COMPUTE_N; i++) {
      const angle = (TWO_PI * (i + 0.5)) / COMPUTE_N;
      const px = s.cx + s.radius * Math.cos(angle);
      const py = s.cy + s.radius * Math.sin(angle);
      const nx = Math.cos(angle), ny = Math.sin(angle);
      const [Ex, Ey] = electricField(px, py);
      flux += (Ex * nx + Ey * ny) * dlC;
    }
    result.net = flux;

    // Visual arrows (N points)
    for (let i = 0; i < N; i++) {
      const angle = (TWO_PI * (i + 0.5)) / N;
      const px = s.cx + s.radius * Math.cos(angle);
      const py = s.cy + s.radius * Math.sin(angle);
      const nx = Math.cos(angle), ny = Math.sin(angle);
      const [Ex, Ey] = electricField(px, py);
      result.arrows.push({ px, py, nx, ny, ex: Ex, ey: Ey, eDotN: Ex * nx + Ey * ny });
    }
  } else {
    result.perSide = true;
    const hw = s.shape === "square" ? s.side / 2 : s.width / 2;
    const hh = s.shape === "square" ? s.side / 2 : s.height / 2;
    const left = s.cx - hw, right = s.cx + hw;
    const top = s.cy - hh, bottom = s.cy + hh;
    const sideW = 2 * hw, sideH = 2 * hh;
    const perimeter = 2 * sideW + 2 * sideH;

    // Distribute visual arrows proportionally among sides
    const nTop = Math.max(2, Math.round(N * sideW / perimeter));
    const nBot = nTop;
    const nLeft = Math.max(2, Math.round(N * sideH / perimeter));
    const nRight = nLeft;

    // High-res compute per side
    function integrateSide(x0, y0, x1, y1, nx, ny) {
      const sLen = Math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2);
      const dl = sLen / COMPUTE_N;
      let flux = 0;
      for (let i = 0; i < COMPUTE_N; i++) {
        const t = (i + 0.5) / COMPUTE_N;
        const px = x0 + (x1 - x0) * t;
        const py = y0 + (y1 - y0) * t;
        const [Ex, Ey] = electricField(px, py);
        flux += (Ex * nx + Ey * ny) * dl;
      }
      return flux;
    }

    function sampleArrows(x0, y0, x1, y1, nx, ny, count) {
      const arr = [];
      for (let i = 0; i < count; i++) {
        const t = (i + 0.5) / count;
        const px = x0 + (x1 - x0) * t;
        const py = y0 + (y1 - y0) * t;
        const [Ex, Ey] = electricField(px, py);
        arr.push({ px, py, nx, ny, ex: Ex, ey: Ey, eDotN: Ex * nx + Ey * ny });
      }
      return arr;
    }

    // Top: y = top, normal (0, -1)
    result.top = integrateSide(left, top, right, top, 0, -1);
    result.arrows.push(...sampleArrows(left, top, right, top, 0, -1, nTop));

    // Bottom: y = bottom, normal (0, +1)
    result.bottom = integrateSide(left, bottom, right, bottom, 0, 1);
    result.arrows.push(...sampleArrows(left, bottom, right, bottom, 0, 1, nBot));

    // Left: x = left, normal (-1, 0)
    result.left = integrateSide(left, top, left, bottom, -1, 0);
    result.arrows.push(...sampleArrows(left, top, left, bottom, -1, 0, nLeft));

    // Right: x = right, normal (+1, 0)
    result.right = integrateSide(right, top, right, bottom, 1, 0);
    result.arrows.push(...sampleArrows(right, top, right, bottom, 1, 0, nRight));

    result.net = result.top + result.bottom + result.left + result.right;
  }
  return result;
}

function computeEnclosedCharge() {
  let q = 0;
  for (const c of state.charges) {
    if (pointInsideSurface(c.x, c.y)) q += c.q;
  }
  return q;
}

// ══════════════════════════════════════════════
// CACHED FLUX
// ══════════════════════════════════════════════
let cachedFlux = { net: 0, top: 0, bottom: 0, left: 0, right: 0, perSide: false, arrows: [] };

// ══════════════════════════════════════════════
// DRAWING
// ══════════════════════════════════════════════

// Grid step from density slider (1=sparse, 10=dense)
function gridStep() {
  return Math.round(82 - (state.density - 1) * 6.89);
}

function drawArrow(x, y, ex, ey, maxLen) {
  const mag = Math.sqrt(ex * ex + ey * ey);
  if (mag < 1e-14) return;
  const len = clamp(mag * 12000, 3, maxLen);
  const ux = ex / mag, uy = ey / mag;
  const tx = x + ux * len, ty = y + uy * len;
  const headLen = clamp(len * 0.35, 2.5, 7);

  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(tx, ty);
  ctx.stroke();

  const angle = Math.atan2(uy, ux);
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(tx - headLen * Math.cos(angle - 0.5), ty - headLen * Math.sin(angle - 0.5));
  ctx.lineTo(tx - headLen * Math.cos(angle + 0.5), ty - headLen * Math.sin(angle + 0.5));
  ctx.closePath();
  ctx.fill();
}

function drawFluxArrow(a) {
  // Draw the full E field vector at the surface point (not just normal component)
  const mag = Math.sqrt(a.ex * a.ex + a.ey * a.ey);
  if (mag < 1e-14) return;
  const maxLen = 70;
  const len = clamp(mag * 18000, 5, maxLen);
  const ux = a.ex / mag, uy = a.ey / mag;
  const tx = a.px + ux * len, ty = a.py + uy * len;
  const headLen = clamp(len * 0.3, 3.5, 9);

  // Color based on flux sign (E·n): orange = outward, purple = inward
  const color = a.eDotN >= 0 ? "rgba(234, 88, 12, 0.9)" : "rgba(124, 58, 237, 0.9)";
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 2.2;

  ctx.beginPath();
  ctx.moveTo(a.px, a.py);
  ctx.lineTo(tx, ty);
  ctx.stroke();

  const angle = Math.atan2(uy, ux);
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(tx - headLen * Math.cos(angle - 0.45), ty - headLen * Math.sin(angle - 0.45));
  ctx.lineTo(tx - headLen * Math.cos(angle + 0.45), ty - headLen * Math.sin(angle + 0.45));
  ctx.closePath();
  ctx.fill();
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  // Background grid dots
  ctx.fillStyle = "#dde3ed";
  const gridBase = 50;
  for (let gx = gridBase / 2; gx < W; gx += gridBase) {
    for (let gy = gridBase / 2; gy < H; gy += gridBase) {
      ctx.beginPath();
      ctx.arc(gx, gy, 1, 0, TWO_PI);
      ctx.fill();
    }
  }

  const step = gridStep();
  const maxArrowLen = step * 0.85;

  // Electric field arrows
  if (state.charges.length > 0 && state.density > 0) {
    ctx.strokeStyle = "rgba(22, 163, 74, 0.5)";
    ctx.fillStyle = "rgba(22, 163, 74, 0.65)";
    ctx.lineWidth = 1.3;
    for (let gx = step / 2; gx < W; gx += step) {
      for (let gy = step / 2; gy < H; gy += step) {
        const [ex, ey] = electricField(gx, gy);
        drawArrow(gx, gy, ex, ey, maxArrowLen);
      }
    }
  }

  // Gaussian surface
  drawSurface();

  // Flux arrows on surface
  if (state.charges.length > 0) {
    for (const a of cachedFlux.arrows) {
      drawFluxArrow(a);
    }
  }

  // Charges (drawn last, on top)
  for (const c of state.charges) {
    drawCharge(c);
  }

  // Canvas text labels
  drawCanvasLabels();
}

function drawSurface() {
  const s = state.surface;
  ctx.strokeStyle = "rgba(180, 83, 9, 0.8)";
  ctx.lineWidth = 2.5;
  ctx.setLineDash([10, 6]);

  if (s.shape === "circle") {
    ctx.beginPath();
    ctx.arc(s.cx, s.cy, s.radius, 0, TWO_PI);
    ctx.stroke();
  } else {
    const hw = s.shape === "square" ? s.side / 2 : s.width / 2;
    const hh = s.shape === "square" ? s.side / 2 : s.height / 2;
    ctx.strokeRect(s.cx - hw, s.cy - hh, hw * 2, hh * 2);
  }
  ctx.setLineDash([]);
}

function drawCanvasLabels() {
  const s = state.surface;
  const flux = cachedFlux;
  // Show Φ_net on canvas near the surface center
  if (s.shape === "circle") {
    drawNetLabel(s.cx, s.cy, flux.net);
  } else {
    const hh = s.shape === "square" ? s.side / 2 : s.height / 2;
    drawNetLabel(s.cx, s.cy + hh - 22, flux.net);
  }
}

function drawNetLabel(x, y, netFlux) {
  ctx.save();
  ctx.font = "800 14px 'Courier New', monospace";
  const text = "\u03A6_net = " + fmt(netFlux);
  const m = ctx.measureText(text);
  const pw = m.width + 14, ph = 22;

  ctx.fillStyle = "rgba(255, 255, 255, 0.92)";
  ctx.beginPath();
  ctx.roundRect(x - pw / 2, y - ph / 2, pw, ph, 5);
  ctx.fill();
  ctx.strokeStyle = "rgba(180,83,9,0.5)";
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.fillStyle = "#92400e";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, x, y + 0.5);
  ctx.restore();
}

function drawCharge(c) {
  const r = 18;
  const isSel = c.id === state.selected;
  const isPos = c.q > 0;
  const inside = pointInsideSurface(c.x, c.y);

  // Selection glow
  if (isSel) {
    ctx.save();
    ctx.shadowColor = isPos ? "rgba(220,38,38,0.5)" : "rgba(37,99,235,0.5)";
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 5, 0, TWO_PI);
    ctx.strokeStyle = isPos ? "#dc2626" : "#2563eb";
    ctx.lineWidth = 2.5;
    ctx.stroke();
    ctx.restore();
  }

  // Inside-surface ring
  if (inside) {
    ctx.beginPath();
    ctx.arc(c.x, c.y, r + 2, 0, TWO_PI);
    ctx.strokeStyle = "rgba(180,83,9,0.5)";
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // Body
  ctx.beginPath();
  ctx.arc(c.x, c.y, r, 0, TWO_PI);
  const grad = ctx.createRadialGradient(c.x - 4, c.y - 4, 2, c.x, c.y, r);
  if (isPos) {
    grad.addColorStop(0, "#fca5a5");
    grad.addColorStop(1, "#dc2626");
  } else {
    grad.addColorStop(0, "#93c5fd");
    grad.addColorStop(1, "#2563eb");
  }
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.strokeStyle = isSel ? "#1e293b" : "rgba(0,0,0,0.15)";
  ctx.lineWidth = isSel ? 2 : 1;
  ctx.stroke();

  // Sign symbol
  ctx.fillStyle = "#fff";
  ctx.font = "bold 20px system-ui, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(isPos ? "+" : "\u2212", c.x, c.y + 1);

  // Index label
  ctx.font = "700 12px system-ui, sans-serif";
  ctx.textBaseline = "alphabetic";
  ctx.fillStyle = "#1e293b";
  ctx.textAlign = "center";
  ctx.fillText("#" + c.id, c.x, c.y - r - 6);
}

// ══════════════════════════════════════════════
// UI UPDATES
// ══════════════════════════════════════════════
function updateFluxReadouts() {
  const el = document.getElementById("fluxReadouts");
  const flux = cachedFlux;
  const qEnc = computeEnclosedCharge();
  const predicted = qEnc; // ε₀ = 1

  let html = "";

  if (flux.perSide) {
    html += `<div class="readout-card">
      <div class="readout-row"><span class="label">\u03A6_top</span><span class="value">${fmt(flux.top)}</span></div>
      <div class="readout-row"><span class="label">\u03A6_bottom</span><span class="value">${fmt(flux.bottom)}</span></div>
      <div class="readout-row"><span class="label">\u03A6_left</span><span class="value">${fmt(flux.left)}</span></div>
      <div class="readout-row"><span class="label">\u03A6_right</span><span class="value">${fmt(flux.right)}</span></div>
      <hr class="divider">
      <div class="readout-row"><span class="label">\u03A6_net</span><span class="value net-val">${fmt(flux.net)}</span></div>
    </div>`;
  } else {
    html += `<div class="readout-card">
      <div class="readout-row"><span class="label">\u03A6_net</span><span class="value net-val">${fmt(flux.net)}</span></div>
    </div>`;
  }

  const qClass = qEnc > 0.01 ? "pos-val" : (qEnc < -0.01 ? "neg-val" : "");
  html += `<div class="readout-card">
    <div class="readout-row"><span class="label">q_enclosed</span><span class="value ${qClass}">${fmt(qEnc)}</span></div>
    <div class="readout-row"><span class="label">Predicted (q/\u03B5\u2080)</span><span class="value green-val">${fmt(predicted)}</span></div>
    <div class="readout-row"><span class="label">Numeric \u03A6</span><span class="value">${fmt(flux.net)}</span></div>
  </div>`;

  el.innerHTML = html;
}

function buildSurfaceSliders() {
  const el = document.getElementById("surfaceSliders");
  const s = state.surface;
  let html = "";
  if (s.shape === "circle") {
    html = `<div class="slider-group">
      <div class="slider-label"><span>Radius</span><span class="val" id="radiusVal">${Math.round(s.radius)}</span></div>
      <input type="range" id="radiusSlider" min="30" max="500" step="1" value="${s.radius}">
    </div>`;
  } else if (s.shape === "square") {
    html = `<div class="slider-group">
      <div class="slider-label"><span>Side</span><span class="val" id="sideVal">${Math.round(s.side)}</span></div>
      <input type="range" id="sideSlider" min="40" max="700" step="1" value="${s.side}">
    </div>`;
  } else {
    html = `<div class="slider-group">
      <div class="slider-label"><span>Width</span><span class="val" id="widthVal">${Math.round(s.width)}</span></div>
      <input type="range" id="widthSlider" min="40" max="800" step="1" value="${s.width}">
    </div>
    <div class="slider-group">
      <div class="slider-label"><span>Height</span><span class="val" id="heightVal">${Math.round(s.height)}</span></div>
      <input type="range" id="heightSlider" min="40" max="600" step="1" value="${s.height}">
    </div>`;
  }
  el.innerHTML = html;

  if (s.shape === "circle") {
    const sl = document.getElementById("radiusSlider");
    sl.addEventListener("input", () => { s.radius = +sl.value; document.getElementById("radiusVal").textContent = Math.round(s.radius); });
  } else if (s.shape === "square") {
    const sl = document.getElementById("sideSlider");
    sl.addEventListener("input", () => { s.side = +sl.value; document.getElementById("sideVal").textContent = Math.round(s.side); });
  } else {
    const wsl = document.getElementById("widthSlider");
    const hsl = document.getElementById("heightSlider");
    wsl.addEventListener("input", () => { s.width = +wsl.value; document.getElementById("widthVal").textContent = Math.round(s.width); });
    hsl.addEventListener("input", () => { s.height = +hsl.value; document.getElementById("heightVal").textContent = Math.round(s.height); });
  }
}

// ══════════════════════════════════════════════
// EVENT HANDLERS
// ══════════════════════════════════════════════
document.getElementById("btnAddPos").addEventListener("click", () => addCharge(1));
document.getElementById("btnAddNeg").addEventListener("click", () => addCharge(-1));
document.getElementById("btnDelete").addEventListener("click", () => {
  if (state.selected !== null) removeCharge(state.selected);
});
document.getElementById("btnReset").addEventListener("click", () => {
  state.charges = [];
  state.selected = null;
  state.nextId = 1;
  state.surface.cx = W / 2;
  state.surface.cy = H / 2;
});

document.getElementById("densitySlider").addEventListener("input", function() {
  state.density = +this.value;
  document.getElementById("densityVal").textContent = this.value;
});
document.getElementById("fluxResSlider").addEventListener("input", function() {
  state.fluxRes = +this.value;
  document.getElementById("fluxResVal").textContent = this.value;
});

document.querySelectorAll(".shape-btn").forEach(btn => {
  btn.addEventListener("click", function() {
    document.querySelectorAll(".shape-btn").forEach(b => b.classList.remove("active"));
    this.classList.add("active");
    state.surface.shape = this.dataset.shape;
    buildSurfaceSliders();
  });
});

// Mobile panel toggle
document.getElementById("panelToggle").addEventListener("click", function() {
  const panel = document.getElementById("panel");
  const collapsed = panel.classList.toggle("collapsed");
  this.innerHTML = collapsed ? "&#9650; Controls" : "&#9660; Hide Controls";
  setTimeout(resize, 50);
});

// ══════════════════════════════════════════════
// MOUSE / TOUCH
// ══════════════════════════════════════════════
function getCanvasPos(e) {
  const rect = canvas.getBoundingClientRect();
  const cx = e.touches ? e.touches[0].clientX : e.clientX;
  const cy = e.touches ? e.touches[0].clientY : e.clientY;
  return { x: cx - rect.left, y: cy - rect.top };
}

function hitTestCharge(mx, my) {
  for (let i = state.charges.length - 1; i >= 0; i--) {
    const c = state.charges[i];
    const dx = mx - c.x, dy = my - c.y;
    if (dx * dx + dy * dy <= 22 * 22) return c;
  }
  return null;
}

function hitTestSurface(mx, my) {
  const s = state.surface;
  if (s.shape === "circle") {
    const dx = mx - s.cx, dy = my - s.cy;
    return Math.sqrt(dx * dx + dy * dy) <= s.radius + 15;
  }
  const b = surfaceBounds();
  const m = 15;
  return mx >= b.x - m && mx <= b.x + b.w + m && my >= b.y - m && my <= b.y + b.h + m;
}

function onPointerDown(e) {
  e.preventDefault();
  const pos = getCanvasPos(e);

  const hit = hitTestCharge(pos.x, pos.y);
  if (hit) {
    selectCharge(hit.id);
    state.dragging = { type: "charge", id: hit.id, ox: pos.x - hit.x, oy: pos.y - hit.y };
    return;
  }

  if (hitTestSurface(pos.x, pos.y)) {
    state.dragging = { type: "surface", ox: pos.x - state.surface.cx, oy: pos.y - state.surface.cy };
    selectCharge(null);
    return;
  }

  selectCharge(null);
}

function onPointerMove(e) {
  if (!state.dragging) return;
  e.preventDefault();
  const pos = getCanvasPos(e);

  if (state.dragging.type === "charge") {
    const c = state.charges.find(ch => ch.id === state.dragging.id);
    if (c) {
      c.x = pos.x - state.dragging.ox;
      c.y = pos.y - state.dragging.oy;
    }
  } else {
    state.surface.cx = pos.x - state.dragging.ox;
    state.surface.cy = pos.y - state.dragging.oy;
  }
}

function onPointerUp() { state.dragging = null; }

canvas.addEventListener("mousedown", onPointerDown);
canvas.addEventListener("mousemove", onPointerMove);
window.addEventListener("mouseup", onPointerUp);
canvas.addEventListener("touchstart", onPointerDown, { passive: false });
canvas.addEventListener("touchmove", onPointerMove, { passive: false });
window.addEventListener("touchend", onPointerUp);

// ══════════════════════════════════════════════
// MAIN LOOP
// ══════════════════════════════════════════════
let lastW = 0, lastH = 0;
function loop() {
  const rect = wrap.getBoundingClientRect();
  if (rect.width !== lastW || rect.height !== lastH) {
    lastW = rect.width;
    lastH = rect.height;
    resize();
  }
  cachedFlux = computeFlux();
  draw();
  updateFluxReadouts();
  requestAnimationFrame(loop);
}

// ══════════════════════════════════════════════
// INIT
// ══════════════════════════════════════════════
buildSurfaceSliders();

addCharge(1);
state.charges[0].x = W / 2 - 50;
state.charges[0].y = H / 2;
addCharge(-1);
state.charges[1].x = W / 2 + 50;
state.charges[1].y = H / 2;
selectCharge(null);

requestAnimationFrame(loop);
</script>
</body>
</html>
